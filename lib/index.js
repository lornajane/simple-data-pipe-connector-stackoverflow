//-------------------------------------------------------------------------------
// Copyright IBM Corp. 2015
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-------------------------------------------------------------------------------

'use strict';

var fs = require('fs');
var _ = require('lodash');
var path = require('path');
var util = require('util');

var pipesSDK = require('simple-data-pipe-sdk');
var connectorExt = pipesSDK.connectorExt;

var bluemixHelperConfig = require.main.require('bluemix-helper-config');
var global = bluemixHelperConfig.global;

var dataSourcePassportStrategy = require('passport-stackexchange').Strategy;

var request = require('request');

/**
 * Connector that retrieves JSON records from Stack Overflow and stores them in Cloudant.
 */
function stackoverflowConnector( parentDirPath ){

	var questionPageSize = 100; // 100 questions per query (max)
	var answerPageSize = 100; // 100 answers per query (max)
	var answerQuestionCount = 100; // 100 question IDs per answer query (max)

	var connectorInfo = {
		id: require('../package.json').simple_data_pipe.name,			// derive internal connector ID from package.json
		name: 'Stack Overflow'								// TODO; change connector display name
	};

	// Customize connector options for the desired behavior of your connector
	var connectorOptions = {
		recreateTargetDb: false, // if set (default: false) all data currently stored in the staging database is removed prior to data load
		useCustomTables: true,   // keep true (default: false)
		updateExistingDocs: true
	};

	// Call constructor from super class; 
	connectorExt.call(this, 
		connectorInfo.id,
		connectorInfo.name,
		connectorOptions
	);

	// writes to the application's global log file
	var globalLog = this.globalLog;

	/**
	 * Returns a fully configured Passport strategy for Stack Overflow. The passport verify
	 * callback adds two properties to the profile: oauth_access_token and oauth_refresh_token.
	 * @override
	 * @returns {Object} Passport strategy for reddit.
	 * */
	this.getPassportStrategy = function(pipe) {

		return new dataSourcePassportStrategy({
			clientID: pipe.clientId,
	        clientSecret: pipe.clientSecret,
	        callbackURL: global.getHostUrl() + '/authCallback',
	        key: pipe.stackoverflowKey,
			scope: 'no_expiry'
		  },
		  function(accessToken, refreshToken, profile, done) {
			  process.nextTick(function () {

			  	// Attach the obtained access token to the user profile
			  	// If applicable; also attach the obtained refresh token to the user profile
			  	// the user profile is passed as a parameter to authCallback()
		        profile.oauth_access_token = accessToken; 
		        profile.oauth_refresh_token = refreshToken;

			    return done(null, profile);
			  });
		  }
		);
	};

	/**
	 * passportAuthCallbackPostProcessing: post processing for OAuth authentication protocol
	 * Stores accessToken + refreshToken and retrieves list of available Stack Overflow tags
	 * that can be queried for questions and moved by the pipe.
	 * @param profile - the output generated by the passport verify callback
	 * @param pipe - data pipe configuration
	 * @param callback(err, pipe ) error information in case of a problem or the updated pipe
	 */
	this.passportAuthCallbackPostProcessing = function( profile, pipe, callback ){
				
        // Set the accessToken and refreshToken from the profile object returned from Passport on the pipe configuration
		pipe.oAuth = {
			accessToken : profile.oauth_access_token,
			refreshToken: profile.oauth_refresh_token
		};

		// Fetch list of data sets that the user can choose from; the list is displayed in the Web UI in the "Filter Data" panel.
        // Attach data set list to the pipe configuration
		this.getStackOverflowDataSetList(pipe, function (err, pipe){
			if(err) {
		    	globalLog.error('OAuth post processing failed. The sample data set list could not be created for data pipe configuration ' + pipe._id + ': ' + err);
		    }	
		    else {
			    globalLog.debug('OAuth post processing completed. Data pipe configuration was updated: ');
			    globalLog.debug(' ' + util.inspect(pipe,3));
		    }	

			return callback(err, pipe);
		});			

	}; // authCallback

	/**
	 * Returns the list of Stack Overflow tags available to the data pipe (sorted by most popular).
	 * @param {Object} pipe - Data pipe configuration
	 * @param {callback} done - invoke after processing is complete or has resulted in an error; parameters (err, updated_pipe)
	 * @return list of data sets (also referred to as tables for legacy reasons) from which the user can choose from
	 */
	this.getStackOverflowDataSetList = function(pipe, done) {
        
        // auth params required to connector to Stack Overflow 
        var authParams = '&access_token=' + encodeURIComponent(pipe.oAuth.accessToken);
        authParams += "&key="  + encodeURIComponent(pipe.stackoverflowKey);
        
        var url = 'https://api.stackexchange.com';
        url += '/2.2/tags'
        url += '?order=desc&sort=popular&site=stackoverflow';
        url += authParams;
        var requestOptions = {
            url : url,
            gzip: true,
            encoding: null
        };
        
        // submit a request to Stack Overflow to retrieve popular tags 
        request.get(requestOptions, function(err, response, body) {
            if(err) {
                // there was a problem with the request; abort processing
                // by calling the callback and passing along an error message
                return done('Fetch request err: ' + err, null);
            }
            
            // get and parse the json response
            var items = JSON.parse(body).items;
            var dataSets = [];
			dataSets.push({name: "custom",label:"CUSTOM"})
            for (var i=0; i<items.length; i++) {
                var name = escapeTag(items[i].name);
				var label = items[i].name;
				dataSets.push({
                    name: name,
                    label: label
                });
            }
            
            // attach the dataSets to the data pipe configuration
            pipe.tables = dataSets;
            
            // invoke callback and pass along the updated data pipe configuration, which now includes a list of data sets the user gets to choose from.
            return done(null, pipe);
        
        }); // request.get
    
    }; // getStackOverflowDataSetList

	/**
	 * Escapes the tag that will be used in the name of the database created in Cloudant.
	 * @param tag - The tag to escape
	 * @returns The escaped tag
     */
	var escapeTag = function(tag) {
		if (tag == "c++") {
			return "cpp";
		}
		else if (tag == "c#") {
			return "csharp";
		}
		else {
			tag = tag.replace(".","dot");
			return tag;
		}
	};

	this.getDesignDocs = function(pipe) {
		return [{
			name: 'questions',
			views: [{
				name: 'by_tag',
				code: {
					reduce: "_sum",
					map: "function (doc) { if (doc.tags) { for (var i=0; i<doc.tags.length; i++) { emit(doc.tags[i], 1); } } }"
				},
				version: 1
			},
				{
					name: 'by_tag_accepted',
					code: {
						reduce: "_sum",
						"map": "function (doc) { if (doc.is_answered && doc.tags) { for (var i=0; i<doc.tags.length; i++) { emit(doc.tags[i], 1); } } }"
					},
					version: 1
				},
				{
					name: "by_tag_not_accepted",
					code: {
						reduce: "_sum",
						map: "function (doc) { if (! doc.is_answered && doc.tags) { for (var i=0; i<doc.tags.length; i++) { emit(doc.tags[i], 1); } } }"
					},
					version: 1
				},
				{
					name: "by_tag_answered",
					code: {
						reduce: "_sum",
						map: "function (doc) { if (doc.answer_count && doc.answer_count > 0 && doc.tags) { for (var i=0; i<doc.tags.length; i++) { emit(doc.tags[i], 1); } } }"
					},
					version: 1
				},
				{
					name: "by_tag_not_answered",
					code: {
						reduce: "_sum",
						map: "function (doc) { if (! doc.is_answered && doc.answer_count == 0 && doc.tags) { for (var i=0; i<doc.tags.length; i++) { emit(doc.tags[i], 1); } } }"
					},
					version: 1
				},
				{
					name: "newest-least-answered",
					code: {
						map: "function (doc) { if (doc.is_answered === false) { emit(doc.creation_date, doc); } }"
					},
					version: 1
				}
			],
			indexes: [{
				name: 'by_tag',
				code: {
					analyzer: "standard",
					index: "function (doc) { if (doc.tags && doc.tags.length > 0) { for (var i=0; i<doc.tags.length; i++) { index(\"tag\", doc.tags[i]); } } }"
				},
				version: 1
			},
				{
					name: "by_tag_answer_status",
					code: {
						analyzer: "standard",
						index: "function (doc) { index(\"accepted\", doc.is_answered); index(\"answered\", doc.answer_count > 0); if (doc.tags) { for (var i=0; i<doc.tags.length; i++) { index(\"tag\",doc.tags[i]); } } }"
					}
				}
			]
		}];
	}

   /**
	* No further processing required as we set the access token to never expire
	* @param done(err) - callback function to be invoked after processing is complete
	* @param pipe - data pipe configuration
	* @param pipeRunLog - a dedicated logger instance that is only available during data pipe runs	
	*/
	this.doConnectStep = function( done, pipeRunStep, pipeRunStats, pipeRunLog, pipe, pipeRunner ){
    	// do nothing by default
    	return done();
	};


	/**
	 * Fetch Stack Overflow questions associated to the selected tag to store in Cloudant.
	 * @param dataSet - dataSet.name contains the data set name that was (directly or indirectly) selected by the user
	 * @param done(err) - callback funtion to be invoked after processing is complete (or a fatal error has been encountered)
	 * @param pipe - data pipe configuration
	 * @param pipeRunLog - a dedicated logger instance that is only available during data pipe runs
	 */
	this.fetchRecords = function( dataSet, pushRecordFn, done, pipeRunStep, pipeRunStats, pipeRunLog, pipe, pipeRunner ){

		var dataSets;
		if (dataSet.name == "custom" && pipe.customTags && pipe.customTags.length > 0) {
			dataSets = pipe.customTags.split(',')
		}
		else {
			dataSets = [dataSet.label]; // use the label as the name is escaped for the database name
		}

		pipeRunLog.info('Fetching ' + dataSets.join() + ' questions from Stack Overflow.');
    
        // auth params required to connect to to Stack Overflow 
        var authParams = '&access_token=' + encodeURIComponent(pipe.oAuth.accessToken);
        authParams += "&key="  + encodeURIComponent(pipe.stackoverflowKey);

		var urlPrefix = 'https://api.stackexchange.com';
		urlPrefix += '/2.2/search'
		urlPrefix += '?order=desc&sort=activity&site=stackoverflow&filter=withbody';
		urlPrefix += '&pagesize=' + questionPageSize;
		urlPrefix += authParams;

		var i = 0;
		var allQuestions = new Array();
		var lastErr = null;
		var statusMessage = "search term(s): " + dataSets[i];
		var dataSetDone = function(err) {
			if (err) {
				lastErr = err;
			}
			if (++i < dataSets.length) {
				statusMessage += ", " + dataSets[i];
				processTag(dataSets[i], urlPrefix, allQuestions, 1, pipe, pipeRunLog, pushRecordFn, dataSetDone);
			}
			else {
				if (pipe.downloadAnswers && allQuestions.length > 0) {
					//
					urlPrefix = 'https://api.stackexchange.com';
					urlPrefix += '/2.2/questions/'
					//
					processAnswers(urlPrefix, authParams, allQuestions, 0, 1, pipe, pipeRunLog, pushRecordFn, function(err) {
						if (err) {
							lastErr = err;
						}
						if (lastErr) {
							return done(lastErr);
						}
						else {
							return done({infoStatus: statusMessage});
						}
					});
				}
				else {
					if (lastErr) {
						return done(lastErr);
					}
					else {
						return done({infoStatus: statusMessage});
					}
				}
			}
		};
		processTag(dataSets[i], urlPrefix, allQuestions, 1, pipe, pipeRunLog, pushRecordFn, dataSetDone);

    }; // fetchRecords


	var processTag = function(tag, urlPrefix, allQuestions, questionPage, pipe, pipeRunLog, pushRecordFn, done) {
		pipeRunLog.info('Retrieving page ' + questionPage + ' of questions for tag <' + tag + '>');
		//
		var url = urlPrefix + '&page=' + questionPage + '&tagged=' + encodeURIComponent(tag);
		var requestOptions = {
			url: url,
			gzip: true,
			encoding: null
		};

		// submit a request to Stack Overflow to retrieve most active questions for the specified tag
		request.get(requestOptions, function (err, response, body) {
			if (err) {
				// there was a problem with the request; abort processing
				// by calling the callback and passing along an error message
				pipeRunLog.error('Error fetching questions from Stack Overflow: ' + err);
				pipeRunLog.error('FFDC: Stack Overflow URL: ' + url);
				return done('Fetch request err: ' + err, pipe);
			}

			// get and parse the json response
			var json = JSON.parse(body);
			if (json.items) {
				var items = json.items;
				for (var i = 0; i < items.length; i++) {
					var key = "q" + items[i].question_id;
					if (! allQuestions[key]) {
						items[i]._id = key; // set the id on the doc - this allows us to overwrite it in subsequent runs
						allQuestions[key] = items[i];
						allQuestions.push(items[i]);
						if (! pipe.downloadAnswers) {
							pushRecordFn(items[i]);
						}
					}
				}
				if ((questionPage*questionPageSize) < pipe.questionCount && json.has_more) {
					processTag(tag, urlPrefix, allQuestions, questionPage+1, pipe, pipeRunLog, pushRecordFn, done);
				}
				else {
					return done();
				}
			}
			else {
				pipeRunLog.error('Error fetching questions from Stack Overflow: Invalid JSON response.');
				pipeRunLog.error('FFDC: Stack Overflow reply: ');
				pipeRunLog.error(' ' + body);
				done(err);
			}

		}); // request.get
	};

	var processAnswers = function(urlPrefix, authParams, questions, questionIndex, answerPage, pipe, pipeRunLog, pushRecordFn, done) {
		//
		var questionIds = "";
		var numQuestions = Math.min(answerQuestionCount,questions.length-questionIndex);
		for (var i=0; i<numQuestions; i++) {
			if (i != 0) {
				questionIds += ";";
			}
			questionIds += questions[questionIndex+i].question_id;
		}
		pipeRunLog.info('Retrieving page ' + answerPage + ' of answers for questions ' + questionIndex + ' - ' + (questionIndex+numQuestions));
		var url = urlPrefix + questionIds + '/answers';
		url += '?order=desc&sort=votes&site=stackoverflow&filter=withbody';
		url += '&page=' + answerPage;
		url += '&pagesize=' + answerPageSize;
		url += authParams;
		var requestOptions = {
			url: url,
			gzip: true,
			encoding: null
		};

		request.get(requestOptions, function (err, response, body) {
			if (err) {
				// there was a problem with the request; abort processing
				// by calling the callback and passing along an error message
				pipeRunLog.error('Error fetching answers from Stack Overflow: ' + err);
				pipeRunLog.error('FFDC: Stack Overflow URL: ' + url);
				return done('Fetch request err: ' + err, pipe);
			}

			// get and parse the json response
			var json = JSON.parse(body);
			if (json.items) {
				var items = json.items;
				for (var i = 0; i < items.length; i++) {
					var key = "q" + items[i].question_id;
					if (questions[key]) {
						if (! questions[key].answers) {
							questions[key].answers = new Array();
						}
						var answerExists = false;
						for (var j=0; j<questions[key].answers.length; j++) {
							if (questions[key].answers[j].answer_id == items[i].answer_id) {
								answerExists = true;
								break;
							}
						}
						if (! answerExists) {
							questions[key].answers.push(items[i]);
						}
					}
				}
				if (json.has_more) {
					processAnswers(urlPrefix, authParams, questions, questionIndex, answerPage+1, pipe, pipeRunLog, pushRecordFn, done);
				}
				else {
					for (var i=0; i<numQuestions; i++) {
						pushRecordFn(questions[i+questionIndex]);
					}
					if ((questionIndex+numQuestions) < questions.length) {
						processAnswers(urlPrefix, authParams, questions, (questionIndex+numQuestions), 1, pipe, pipeRunLog, pushRecordFn, done);
					}
					else {
						return done();
					}
				}
			}
			else {
				pipeRunLog.error('Error fetching answers from Stack Overflow: Invalid JSON response.');
				pipeRunLog.error('FFDC: Stack Overflow reply: ');
				pipeRunLog.error(' ' + body);
				done(err);
			}

		}); // request.get
	};

	/**
	 * This function returns the prefix to be used when creating a new Cloudant database.
	 */
	this.getTablePrefix = function(){
		// The prefix is used to generate names for the Cloudant staging databases that hold your data. The recommended
		// value is the connector ID to assure uniqueness.
		return connectorInfo.id;
	};
}

//Extend event Emitter
util.inherits(stackoverflowConnector, connectorExt);

module.exports = new stackoverflowConnector();